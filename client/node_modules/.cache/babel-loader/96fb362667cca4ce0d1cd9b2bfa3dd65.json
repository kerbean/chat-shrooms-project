{"ast":null,"code":"/* \n    JSON-Find\nSmall utility for searching through JSON or a JSON-compatible object for values at\ngiven keys.  \n*/\n'use strict';\n/**** JSON document ***\n    \"this\" assumes an Object or Array */\n\nvar _defineProperty = require(\"/Users/helengrace.delrosario/Desktop/BOOTCAMP/ACTIVITIES/WEEK23/PROJECT 3/Unsolved/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar JSON_DATA = Object.create({}, {\n  checkKey: {\n    configurable: false,\n    enumerable: false,\n\n    /* object at given key or false */\n    value: function value(key) {\n      return reduceJSON(false, this, function (n, m) {\n        return m;\n      }, key);\n    }\n  },\n  findValues: {\n    configurable: false,\n    enumerable: false,\n\n    /* object at given key or false */\n    value: function value() {\n      for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n        keys[_key] = arguments[_key];\n      }\n\n      return findValues.apply(void 0, [this].concat(keys));\n    }\n  },\n  extractPaths: {\n    configurable: false,\n    enumerable: false,\n\n    /* extract objects at given paths */\n    value: function value(useNewKeys) {\n      for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        keys[_key2 - 1] = arguments[_key2];\n      }\n\n      return extractPaths.apply(void 0, [this, useNewKeys].concat(keys));\n    }\n  }\n});\n/*** Constructor *** \n    JsonFind will return Atoms as is, Arrays & Objects are\n    converted to JsonFind Object */\n\nfunction JsonFind(doc) {\n  var possibleJson = JSON.stringify(doc);\n\n  if (possibleJson === undefined) {\n    throw new Error('Object is invalid JSON');\n  } else if (isAtom(doc) || doc === null) {\n    return doc;\n  } else {\n    return Object.assign(Object.create(JSON_DATA), doc);\n  }\n}\n\nvar assignments = function () {\n  Object.assign(JsonFind, {\n    prototype: JSON_DATA\n  });\n}();\n\nmodule.exports = JsonFind;\n/*** JSON_DATA methods ***/\n\n/* Object, ...String -> Object\n    searches through an object for all given keys,\n    return an object of search keys & their values  */\n\nfunction findValues(toSearch) {\n  for (var _len3 = arguments.length, searchFor = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    searchFor[_key3 - 1] = arguments[_key3];\n  }\n\n  var searchesLen = searchFor.length;\n  var results = {};\n  var searches = {};\n\n  for (var i = 0; i < searchesLen; i++) {\n    searches[searchFor[i]] = true;\n  }\n  /* Object, Object -> Void */\n\n\n  function traverseObject(toSearchObj, searchForObj) {\n    var allKeys = Object.keys(toSearchObj);\n    var len = allKeys.length;\n\n    for (var _i = 0; _i < len; _i++) {\n      var key = allKeys[_i];\n      var val = toSearchObj[key];\n\n      if (searchForObj[key] && !results[key]) {\n        results[key] = val;\n      } else if (isObject(val)) {\n        traverseObject(val, searchForObj);\n      } else if (isArray(val)) {\n        traverseArray(val, searchForObj);\n      }\n    }\n  }\n  /* Array, Object -> Void */\n\n\n  function traverseArray(arr, searchForObj) {\n    var len = arr.length;\n\n    for (var _i2 = 0; _i2 < len; _i2++) {\n      var item = arr[_i2];\n\n      if (isArray(item)) {\n        traverseArray(item, searchForObj);\n      } else if (isObject(item)) {\n        traverseObject(item, searchForObj);\n      }\n    }\n  }\n\n  traverseObject(toSearch, searches);\n  return results;\n}\n/* applies function to value at given key */\n\n\nfunction reduceJSON(accum, json, fn, searchFor) {\n  if (isKey(json, searchFor)) {\n    return fn(accum, json[searchFor]);\n  } else if (isAtom(json)) {\n    return accum;\n  } else if (isArray(json)) {\n    return json.reduce(function (acc, item) {\n      return reduceJSON(acc, item, fn, searchFor);\n    }, accum);\n  } else {\n    var keys = Object.keys(json);\n    return keys.reduce(function (acc, key) {\n      return reduceJSON(acc, json[key], fn, searchFor);\n    }, accum);\n  }\n}\n/* Object, Array-of-String, ...Array-of-String -> Object \n    extracts values from an object from multiples paths: \n    a Path is [...String] \n    assumes newKeys is false or [...String] */\n\n\nfunction extractPaths(obj, newKeys) {\n  var nkLen = newKeys.length;\n\n  for (var _len4 = arguments.length, paths = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    paths[_key4 - 2] = arguments[_key4];\n  }\n\n  var pLen = paths.length;\n  var curried = curry(assignKeysAtPaths, obj, newKeys, paths);\n  return nkLen > pLen ? curried(nkLen) : curried(pLen);\n}\n/*** Helpers ***/\n\n/* JSON, [...String], [...[...String]], Number -> Object */\n\n\nfunction assignKeysAtPaths(obj, newKeys, paths, loopLen) {\n  var result = {};\n\n  for (var i = 0; i < loopLen; i++) {\n    // allows for unequal newKeys/paths lengths\n    var iPath = paths[i] ? paths[i] : null;\n    var iNewKey = newKeys[i] ? newKeys[i] : paths[i].slice(-1);\n    var objAtPath = iPath === null ? null : recurPath(obj, iPath);\n    var key = objAtPath ? Object.keys(objAtPath)[0] : null;\n    var curried = curry(Object.assign, result); // prevent same keys from overriding\n\n    if (newKeys) {\n      if (objAtPath) {\n        curried(_defineProperty({}, iNewKey, objAtPath[key]));\n      } else {\n        curried(_defineProperty({}, iNewKey, objAtPath));\n      }\n    } else if (key in result) {\n      curried(_defineProperty({}, key + '+' + i, objAtPath[key]));\n    } else {\n      curried(objAtPath);\n    }\n  }\n\n  return result;\n}\n/* Object, Array-of-String -> Object\n    retrieves the value of an object at the given path\n    returns { String-X: object }\n    where String-X is the key from the last index of \n    the given array */\n\n\nfunction recurPath(obj, arr) {\n  var lastKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (arr.length === 0) {\n    return _defineProperty({}, lastKey, obj);\n  } else {\n    return recurPath(obj[arr[0]], arr.slice(1), arr[0]);\n  }\n}\n/* [[...X -> Y], ...X -> [...Y -> Z]] -> Z */\n\n\nfunction curry(fn) {\n  for (var _len5 = arguments.length, firstArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    firstArgs[_key5 - 1] = arguments[_key5];\n  }\n\n  return function () {\n    for (var _len6 = arguments.length, secondArgs = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      secondArgs[_key6] = arguments[_key6];\n    }\n\n    return fn.apply(null, firstArgs.concat(secondArgs));\n  };\n}\n\nfunction isAtom(v) {\n  return undefined === v || null === v || typeof v === 'boolean' || typeof v === 'number' || typeof v === 'string';\n}\n\nfunction isArray(v) {\n  return Array.isArray(v);\n}\n\nfunction isObject(v) {\n  return typeof v === 'object' && !isArray(v) && v !== null;\n}\n\nfunction isCompound(v) {\n  return isArray(v) || isObject(v);\n}\n\nfunction isKey(json, searchFor) {\n  return json === null ? false : isCompound(json) && searchFor in json;\n}","map":null,"metadata":{},"sourceType":"script"}